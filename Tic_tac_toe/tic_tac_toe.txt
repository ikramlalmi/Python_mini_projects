creating a command line version of Tic Tac Toe, whihc various types of players, either human can play agaisnt the computer or the
the computer can play against each other, or the computer can play against the computer.
we will first split up the player and the game into two seperate classes, so that when we actually play, we can tell the game this is x player 
and this is o player. 
we will prob need math and random
we will have a base player class, we will intialize wiht the ltter that the player is going to represent. it iwill be either X or O.

    {self represents the instance of the class. By using the “self” keyword we can access the attributes and methods of the class in python. It binds the attributes with the given arguments.
    the first parameter of methods is the instance the method is called on.
    Self is always pointing to Current Object.}
we want all players to be able to get their next move given a game. we will pass beacause this is our base player class, and on top of it we will buid a random computer player.
and we will build a human player. here we will use inheretance in order to create random computer player and a human computer player that will build on top of this base player object
    
    {In Python, object is the base class from which all other classes are derived. In the above example, we have done this using super().}

In the intialization we have to initialize the super class, using super(), it will class on the base class player.
in the human player super class , the super class is till player, so we pass it as an arg. 
now let's define the game in another file. to see exactely what we are dealing with when we pas in the game
define class tic_tac_toe, we will need a board in this class. because our tictoctoe is a 3*3 board. notice that the bord was not passed in the init method, cs we need to create.
self.board = [], so will a list of length 9 that will represent the board. we will assign an index to this length 9 list to each of the spaces.
    {_ By convention _ means to other developers that the variable is unused.}
we will aslo have a var current winner that will keep track of weather or not there is a winner in the game, and who is it.
No we will define a method to print the board. we will wanna see what's on the board, we will split this up into the rows, so for each row, this will index into 
length 9 list  for i in range(3), 

the i*3:(i+1)*3: this is basically saying which group of three spaces are we choosing, is it the first, 2nd or 3rd one?
indices -,1,2: that represent the first row, and indices 3,4,5 that represent the 2nd row.....
for each row we will print, print the seperators, and "|".join(row), just saying join them in a string where the separator is the pipe line.
the "|" and the last "|", that is for the board borders. 

Now wiht print_board_nums it is a static method bcz it does not relate any specific board, so no need to pass a self. 
it will print out which num corresponds to which spot. so the j in range (3), is the numof rows and we have 3 of them

now lets dig a little deeper in the logic of the game. as of now we are representing the empty spaces with a space, and 
we will need to know what are the available moves after you makw a move, we will return a list of indices.
lets initialize moves as an empty list and say 
enumerate will create a list wiht tuples and assign tuples that have the (index, value at that index), ['x','x','1']->(0,'x'), (1,'x'), in the for loop we going through the tuples and we are assigning first item to i and second item to x
if the spot == " ", we know that this is an empty spce and we will apend the index of that spot to the moves list that had avaible moves, and at the end we will retun moves.
the anotehr way to write this is a list comprehension. this is will condence the whole block of code in a line. 
return[for i in i, spot in enumerate(self.board) if spot == " "]



Now let's define the random computerplayer get move method, we will choose a random spot on the board that is empty, and call is square. 
for the human player, we want it to be able to choose a spot based on some input that we pass in throught the terminal. We want the user
to keep iterating until they ascheive a valid square. intialy the value of valid_square will be false and, and the val will be None. now ask user for the input, and we will tell the user 
if it is their turn, (self.letter will be either X or o)
we will incorporate  series of checks to make sure that this is a valid num that we can put in. 
The checks: we will check that this is a correct value by trying to cast it to an integer, and if it is not, then 
we say it is unvalid. If thats pot is invalid in the board we say it is also invalid. so try : val = int(square), and if 
val not in game.avaible_moves(), we will raise a value error. so either one of these two thinsg go wrong, then we know it is not valid.
if we pass both of these consitions, we can say valid square==True. now we will catch the value error,a dn say print ("")
this will repeat the loop, until we get a valid square. at the very end we will retun the val once we get a valid square.
now it will be the human player next move. 
Let add a function a called play outside if the class, where we will mass a game, and x)player and an o_player,
and a variable print_game, that will just be set to true or false, so that it will print all the steps, but later when the computer is playing against it self 
We don't need not see all of the steps, and have the computer print out every single game, we can toggle it to false. 
If we will print the game, we will call the print print_board_nums fucntion to see the board, and which nums correspond to which spot. 
starting letter will be x, could o too.
while to game still has empty squares, or is still incomplete we will still ietrate.we dont have to worry abt the winner
because the output if the loop will return the winner. 
In order to check weather the game still has emppty square, we will create another fucntin wihtin the class.
create the fucntion and return " " in self.board, which is a boolean, it will retun T or F 
if there is empty squares.
We also wanna know the number of empty square, so we will say, return length of available moves, it will retun the num of empty squares, or we could just say self.board.count(' '), it will count the 
number of empty spaces. 
While there are empty squares we want to get the move from the approriate player, while the letter is equal to o, we will ask the o player to get the move,
else it is the x player, and we will ask them to get the move.

Now let's define the function to make the move, now that we get the players to get their next move, what move are they gonna take?
function make move, we need info abt what square the user wants their move to be at and what letter they will choose. if the move is valid we will
we will assign a square to a letter, and return True, otherwise we will return False. so self.board[square], is empty we will assign the letter to the given square and 
we return True, otherwise return false. Now add that the play function.  
if game.make_move is valid, and print_game is true , we want to print in the terminal that letter(player) makes move to square{}
now we want to see a new represantation of the board where this spot now has been claimed: game.print_board() 
print('') is just an empty line that we are printing. 

after we made our move, we need to alternate letters, here we will assign letter= O if the old letter was x otherwise assign it to x.
two diff ways to do it. 
but wait technically every time, you make a move, you could win! go back to the the function make_move, after we place th letter in the sqaure, we can toggle current winner to the winner if there is one. 
so lets' make another fucntion that checks for the winner after we make a move, and we will apss in out last move in the make move fucntion, bcz that is going to be winning move. if that is the winning move, we can assign current winner= to that players letter. 

now in the play fucntin, after we make a move, we will chech for the current winner before we switch letters. so if the current winner is not set anymore, a leteer has won, and retur the letter that give us the win, and we can end the game.
so if game.current_winner: we can return the winner of the game. so in this game we will return the winner if there is one, or none= it is tie. 
let's add in the none for the tie at the bottom, so if print game, after this while loop is over, we can print it is a tie.
so now let's create the fucntion that defines the winner, we will input the square and letter.
We know that in tic_tac_toe, of there is a 3 on a row anywhere, but we have to chekc all of the possibilites. 
either in the row, column or diagonal. first check the row, so the index of the row, si going to be what ever square you give it and devide it by 3 and round it down. {ex: 4//3=1index} so the // is rounding down

row var is going to be a list of items in the row we have selected. so self.board at index row. givenn he row index get the row. if all in the list is true, this comes ou to be true. for every spot in the list row we will check if that spot ==letter (all ==o), then return true, we have 3 in a row. 
now let's check the column next, so for the column index, square devided by 3 and take left over suing the mudulo operator % {square 4%3=1 }. then we will have hte list column, that will have the entire col: so we take the col index and for every single row=i, if we add the col index you will get the entire col values. 
then we will use the if all checker, if evrything in the column, is equal to the letter we will return T, finnaly we will check the diagonals.
so the only way to win a diagonal is to place a move along the diagonal at the sqaure num{0,2, 4, 6, 8}, so chekc if the square that we moved to is an even number, so if the square is dvisible by 2 using the mudulo operator, then we will create a list diagonal1, that will have the squre wiht index 0,4,8.
for the diagnal, we will put the squares wiht index 2,4,6.  we will once again use the if checker, so if every spot in diagonal 1 or 2 is equal the same letter, return true.
if all these checks fails, we dont have a winner so we can return false. 

if name == main, we will make the x player equals to the human player, assign it the letter x. we also have to import human player and computer player, other wise game,py has no idea what is in th eplayer.py. do for our x player we will create a human player and initilize it wiht the letter x, same wiht o player
and for our game we will call it t, and it will be an instance of tic_tac_toe, then we will call the fucntion.
and pass in the game: t , and the o_player and the x player, and set the game =True. to add in tiny pause after each player plays, we can call in time.sleep(0.8), and that is 0.8 seconds. and import time. 
